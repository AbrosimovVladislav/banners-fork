package ru.promopult.aibannersgenerator.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import ru.promopult.aibannersgenerator.domain.RequestAndPrompt;
import ru.promopult.aibannersgenerator.exception.GetPromptException;
import ru.promopult.aibannersgenerator.integration.chatgpt.client.ChatGPTClient;
import ru.promopult.aibannersgenerator.integration.chatgpt.model.request.ChatGPTRequest;
import ru.promopult.aibannersgenerator.integration.chatgpt.model.response.ChatGPTResponse;

@Slf4j
@Service
@RequiredArgsConstructor
public class PromptService {

  private final ChatGPTClient chatGPTClient;
  private final PromptSchemaGenerator promptSchemaGenerator;
  private final ObjectMapper objectMapper = new ObjectMapper();

  public RequestAndPrompt getPromptForImageAI(String landingUrl, String conceptRequest,
      String styleDescription) {
    log.info("[PROMPT-SERVICE] Prompt receiving for url:<{}> started", landingUrl);

    String promptSchema = promptSchemaGenerator.getDefaultPromptSchema();
    String promptRequestContent = insertConceptIntoPromptRequest(conceptRequest, promptSchema,
        styleDescription);
    ChatGPTRequest request = new ChatGPTRequest().createDefaultRequest(promptRequestContent);

    ResponseEntity<ChatGPTResponse> response = chatGPTClient.call(landingUrl, request);

    ConceptAndPrompt conceptAndPrompt = getPromptFromResponseBody(response.getBody());
    String prompt = conceptAndPrompt.getPrompt();
    prompt = preparePrompt(prompt, styleDescription);
    log.info("[PROMPT-SERVICE] Prompt successfully received: <{}>", prompt);
    return RequestAndPrompt.builder().promptRequest(promptRequestContent).prompt(prompt).build();
  }

  private String preparePrompt(String prompt, String styleDescription) {
    prompt = styleDescription + " " + prompt;
    return prompt;
  }

  private String insertConceptIntoPromptRequest(String conceptRequest, String promptSchema,
      String styleDescription) {
    String prompt = promptSchema.replace("{conceptRequest}", conceptRequest);
    prompt = prompt.replace("{styleDescription}", styleDescription);
    return prompt;
  }

  private ConceptAndPrompt getPromptFromResponseBody(ChatGPTResponse responseBody) {
    String content = responseBody.getChoices().get(0).getMessage().getContent();
    content = prepareContent(content);
    ConceptAndPrompt conceptAndPrompt;
    try {
      conceptAndPrompt = objectMapper.readValue(content, ConceptAndPrompt.class);
    } catch (Exception e) {
      throw new GetPromptException(responseBody.getId(), content);
    }

    if (conceptAndPrompt.getPrompt() == null) {
      throw new RuntimeException(
          "Prompt generated by request with gptResponseId:<" + responseBody.getId() + "> is null");
    }

    return conceptAndPrompt;
  }

  private String prepareContent(String content) {
    content = content.replaceAll("[<>]", "");
    if (content.contains("{") && content.contains("}")) {
      content = content.substring(content.indexOf("{"), content.indexOf("}") + 1);
    }
    return content;
  }

  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  public static class ConceptAndPrompt {

    private String concept;
    private String prompt;
  }
}
